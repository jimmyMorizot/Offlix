# API 2/2

## JSON et les Groups

Quand on est en mode "API", notre objectif est de renvoyer du JSON.

Simple en PHP, on `serialize` nos objets, mais avec doctrine et les relations entre nos objets, ben c'est pas la m√™me.

Pourquoi ?

Parce que Doctrine est trop sympa, il nous ram√®ne tout ce qu'on lui demande d√®s qu'on lui demande.
Donc quand on transforme un objet en JSON, on parcours toutes ses propri√©t√©s, et Doctrine fait son taf üí•

Pour cela Symfony nous propose de faire des annotations `@Groups` sur chaque propri√©t√© pour pouvoir bien sp√©cifier ce que l'on veux renvoyer comme donn√©es.

```php
use Symfony\Component\Serializer\Annotation\Groups;

/*
* @Groups({"get_movies"})
*/
```

On peut mettre plusieur nom de groupe sur une propri√©t√©

```php
/*
* @Groups({"get_movies", "get_movies_collection"})
*/
```

Il ne nous reste plus qu'a dire √† Symfony quel groupe utiliser pour serializer notre json

```php
return $this->json(
            // Les donn√©es √† s√©rialiser (√† convertir en JSON)
            $moviesList,
            // Le status code
            200,
            // Les en-t√™tes de r√©ponse √† ajouter (aucune)
            [],
            // Les groupes √† utiliser par le Serializer
            ['groups' => 'get_movies_collection']
        );
```

Super tout √ßa, mais √ßa va devenir rapidement compliqu√© si on a une API bien fournie.

Une id√©e de bonne pratique est d'utiliser des noms de groupe par entit√© :

* Movies : get_movies, get_movies_collection
* Genres : get_genres, get_genres_collection

Donc si je veux renvoyer un `movie` avec ses `genre`, on va pouvoir pr√©ciser tout les groupes √† utiliser.

```php
return $this->json(
            // Les donn√©es √† s√©rialiser (√† convertir en JSON)
            $moviesListWithGenre,
            // Le status code
            200,
            // Les en-t√™tes de r√©ponse √† ajouter (aucune)
            [],
            // Les groupes √† utiliser par le Serializer
            ['groups' => [
                'get_movies',
                'get_genres_collection'
                ]
            ]
        );
```

## POST et deserialize

Quand on est en mode "API", si on permet la cr√©ation avec la route `POST`, on doit s'attendre √† recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on re√ßoit et üí• on a un objet PHP.

On injecte la requ√®te HTTP dans notre fonction pour en r√©cup√©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;

public function createItem(Request $request)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme pr√©vu on `deserialize`, c'est √† dire que l'on transforme le JSON en Objet en pr√©cisant l'entit√© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;

public function createItem(Request $request, SerializerInterface $serializer)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

üéâ trop facile, on donnes √ßa √† Doctrine pour qu'il le mettes en BDD et c'est bon üí™

```php
use Doctrine\Persistence\ManagerRegistry;
public function createItem(Request $request, SerializerInterface $serializer, ManagerRegistry $doctrine)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entit√©
    $entityManager = $doctrine->getManager();
    $entityManager->persist($movie);
    $entityManager->flush();

```

üòÖ `SQLSTATE[xxxx] xxxx cannot be null`

Comment √ßa MySQL n'est pas content ? üëø

Ben oui, il manque des donn√©es, on va demander √† Symfony de nous valider tout √ßa üí™ et surtout de nous dire ce qui coince.
Comme √ßa on pr√©vient notre utilisateur en front et on lui d√©crit les probl√®mes pour qu'il s'adapte et qu'il nous envoie les bonnes donn√©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;

public function createItem(Request $request, SerializerInterface $serializer, ManagerRegistry $doctrine, ValidatorInterface $validator)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entit√©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);

    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // @todo Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entit√©
    $entityManager = $doctrine->getManager();
    $entityManager->persist($movie);
    $entityManager->flush();
```

### Relations

Si besoin d'associer des entit√©s existantes (par ex. genres sur movie), on envoie un tableau d'ids dans la propri√©t√© JSON concern√©e, ex. : 

```json
{
  "title": "Avatar",
  "type": "Film",
  "duration": 120,
  "rating": 5,
  "summary": "xxx",
  "synopsis": "xxx",
  "releaseDate": "1984-10-05T02:00:44+01:00",
  "poster": "https://m.media-amazon.com/images/M/MV5BYjg4ZjUzMzMtYzlmYi00YTcwLTlkOWUtYWFmY2RhNjliODQzXkEyXkFqcGdeQXVyNTUyMzE4Mzg@._V1_SX300.jpg",
  "genres": [1, 2]
}
```

Et on doit mettre en place un _Entity Denormalizer_ pour permettre au Serializer de convertir l'id en entit√© Doctrine.

Exemple de code : https://gist.github.com/benlac/c9efc733ee16ebd0d438119bcccb92b9 (la config du `services.yaml` semble √™tre optionnelle).

### PUT/PATCH

Pour modifier une entit√©, c'est comme POST mais avec une param√®tre en plus. Et on r√©cup√®re l'entit√© avec le ParamConverter.

Voir [Deserializing in an existing object](https://symfony.com/doc/5.4/components/serializer.html#deserializing-in-an-existing-object).

```php
$serializer->deserialize($data, Person::class, 'xml', [AbstractNormalizer::OBJECT_TO_POPULATE => $person]);
```

### CORS

Si les domaines ou ports de client et du serveur sont diff√©rents, avec Javascript, la r√®gle de s√©curit√© des CORS va s'appliquer.

Pour cela le serveur soit autoriser, soit un ou des noms de domaine, soit tout le monde, via l'en-t√™te de r√©ponse `'Access-Control-Allow-Origin'` (voir le contr√¥leur `Api\Movie::getCollection`).

Si on souhaite g√©rer ces en-t√™tes pour toutes les routes de l'API automatiquement, on peut utiliser ce Bundle : https://github.com/nelmio/NelmioCorsBundle