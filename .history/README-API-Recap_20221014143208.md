# API 2/2

## JSON et les Groups

Quand on est en mode "API", notre objectif est de renvoyer du JSON.

Simple en PHP, on `serialize` nos objets, mais avec doctrine et les relations entre nos objets, ben c'est pas la mÃªme.

Pourquoi ?

Parce que Doctrine est trop sympa, il nous ramÃ¨ne tout ce qu'on lui demande dÃ¨s qu'on lui demande.
Donc quand on transforme un objet en JSON, on parcours toutes ses propriÃ©tÃ©s, et Doctrine fait son taf ðŸ’¥

Pour cela Symfony nous propose de faire des annotations `@Groups` sur chaque propriÃ©tÃ© pour pouvoir bien spÃ©cifier ce que l'on veux renvoyer comme donnÃ©es.

```php
use Symfony\Component\Serializer\Annotation\Groups;

/*
* @Groups({"get_movies"})
*/
```

On peut mettre plusieur nom de groupe sur une propriÃ©tÃ©

```php
/*
* @Groups({"get_movies", "get_movies_collection"})
*/
```

Il ne nous reste plus qu'a dire Ã  Symfony quel groupe utiliser pour serializer notre json

```php
return $this->json(
            // Les donnÃ©es Ã  sÃ©rialiser (Ã  convertir en JSON)
            $moviesList,
            // Le status code
            200,
            // Les en-tÃªtes de rÃ©ponse Ã  ajouter (aucune)
            [],
            // Les groupes Ã  utiliser par le Serializer
            ['groups' => 'get_movies_collection']
        );
```

Super tout Ã§a, mais Ã§a va devenir rapidement compliquÃ© si on a une API bien fournie.

Une idÃ©e de bonne pratique est d'utiliser des noms de groupe par entitÃ© :

* Movies : get_movies, get_movies_collection
* Genres : get_genres, get_genres_collection

Donc si je veux renvoyer un `movie` avec ses `genre`, on va pouvoir prÃ©ciser tout les groupes Ã  utiliser.

```php
return $this->json(
            // Les donnÃ©es Ã  sÃ©rialiser (Ã  convertir en JSON)
            $moviesListWithGenre,
            // Le status code
            200,
            // Les en-tÃªtes de rÃ©ponse Ã  ajouter (aucune)
            [],
            // Les groupes Ã  utiliser par le Serializer
            ['groups' => [
                'get_movies',
                'get_genres_collection'
                ]
            ]
        );
```

## POST et deserialize

Quand on est en mode "API", si on permet la crÃ©ation avec la route `POST`, on doit s'attendre Ã  recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on reÃ§oit et ðŸ’¥ on a un objet PHP.

On injecte la requÃ¨te HTTP dans notre fonction pour en rÃ©cupÃ©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;

public function createItem(Request $request)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme prÃ©vu on `deserialize`, c'est Ã  dire que l'on transforme le JSON en Objet en prÃ©cisant l'entitÃ© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;

public function createItem(Request $request, SerializerInterface $serializer)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

ðŸŽ‰ trop facile, on donnes Ã§a Ã  Doctrine pour qu'il le mettes en BDD et c'est bon ðŸ’ª

```php
use Doctrine\Persistence\ManagerRegistry;
public function createItem(Request $request, SerializerInterface $serializer, ManagerRegistry $doctrine)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entitÃ©
    $entityManager = $doctrine->getManager();
    $entityManager->persist($movie);
    $entityManager->flush();

```

ðŸ˜… `SQLSTATE[xxxx] xxxx cannot be null`

Comment Ã§a MySQL n'est pas content ? ðŸ‘¿

Ben oui, il manque des donnÃ©es, on va demander Ã  Symfony de nous valider tout Ã§a ðŸ’ª et surtout de nous dire ce qui coince.
Comme Ã§a on prÃ©vient notre utilisateur en front et on lui dÃ©crit les problÃ¨mes pour qu'il s'adapte et qu'il nous envoie les bonnes donnÃ©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;

public function createItem(Request $request, SerializerInterface $serializer, ManagerRegistry $doctrine, ValidatorInterface $validator)
{
    // RÃ©cupÃ©rer le contenu JSON
    $jsonContent = $request->getContent();
    // DÃ©sÃ©rialiser (convertir) le JSON en entitÃ© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entitÃ©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);

    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // @todo Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entitÃ©
    $entityManager = $doctrine->getManager();
    $entityManager->persist($movie);
    $entityManager->flush();
```

### Relations

Si besoin d'associer des entitÃ©s existantes (par ex. genres sur movie), on envoie un tableau d'ids dans la propriÃ©tÃ© JSON concernÃ©e, ex. : 

```json
{
  "title": "Avatar",
  "type": "Film",
  "duration": 120,
  "rating": 5,
  "summary": "xxx",
  "synopsis": "xxx",
  "releaseDate": "1984-10-05T02:00:44+01:00",
  "poster": "https://m.media-amazon.com/images/M/MV5BYjg4ZjUzMzMtYzlmYi00YTcwLTlkOWUtYWFmY2RhNjliODQzXkEyXkFqcGdeQXVyNTUyMzE4Mzg@._V1_SX300.jpg",
  "genres": [1, 2]
}
```

Et on doit mettre en place un _Entity Denormalizer_ pour permettre au Serializer de convertir l'id en entitÃ© Doctrine.

Exemple de code : https://gist.github.com/benlac/c9efc733ee16ebd0d438119bcccb92b9 (la config du `services.yaml` semble Ãªtre optionnelle).

### PUT/PATCH

Pour modifier une entitÃ©, c'est comme POST mais avec une paramÃ¨tre en plus.

Voir [Deserializing in an existing object](https://symfony.com/doc/5.4/components/serializer.html#deserializing-in-an-existing-object).

```php
$serializer->deserialize($data, Person::class, 'xml', [AbstractNormalizer::OBJECT_TO_POPULATE => $person]);
```